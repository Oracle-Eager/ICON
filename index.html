<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ICON</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/lucide@latest"></script>

    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    fontFamily: { sans: ['Inter', 'sans-serif'] },
                    colors: {
                        'accent': '#3B82F6', 'accent-dark': '#2563EB',
                        'bg-primary': '#0A0A0A', 'bg-secondary': '#121212',
                        'bg-tertiary': '#1C1C1E', 'text-primary': '#FFFFFF', 'text-secondary': '#A0A0A0',
                        'text-tertiary': '#606060',
                    }
                }
            }
        }
    </script>

    <style>
        html, body { height: 100%; overflow: hidden; }
        body { 
            -webkit-tap-highlight-color: transparent; 
            user-select: none; 
            background: linear-gradient(180deg, #121212 0%, #0A0A0A 100%);
        }
        ::-webkit-scrollbar { display: none; }

        #header-title { text-shadow: 0 2px 10px rgba(255, 255, 255, 0.1); }

        /* --- SMOOTHER ANIMATIONS --- */
        #mini-player, #full-player, #queue-view {
            transition: all 500ms cubic-bezier(0.4, 0, 0.2, 1);
        }
        #search-container {
            transition: all 300ms ease-out;
        }

        /* --- REDESIGNED PROGRESS BAR (THUMBLESS) --- */
        #full-player input[type=range] {
            -webkit-appearance: none; appearance: none;
            background: transparent; cursor: pointer; width: 100%;
            height: 1.5rem; padding: 0; margin: 0;
        }
        #full-player input[type=range]::-webkit-slider-runnable-track {
            background: linear-gradient(to right, white var(--progress, 0%), rgba(255,255,255,0.2) var(--progress, 0%));
            height: 0.25rem; border-radius: 1rem;
        }
        #full-player input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none;
            width: 0; height: 0; border: 0; box-shadow: none;
        }

        /* --- ADVANCED FLOATING UI (ICON-ONLY) --- */
        #main-nav, #player-nav {
            left: 50%;
            transform: translateX(-50%);
            width: auto;
            bottom: 1rem;
            border-radius: 9999px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3), 0 0 0 1px rgba(255, 255, 255, 0.1);
            border-top: none;
        }
        .tab-item {
            padding: 0.5rem;
            transition: transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        .tab-item:active {
            transform: scale(0.9);
        }
        .icon-wrapper {
            width: 3rem; height: 3rem;
            border-radius: 9999px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto;
            transition: all 0.3s ease;
        }
        .tab-item.active .icon-wrapper {
            background-color: theme('colors.accent');
            transform: scale(1.1);
            box-shadow: 0 0 20px theme('colors.accent');
        }
        .tab-item.active i {
            color: white;
        }
        
        #player-carousel { overflow: hidden; }
        #header { transition: background-color 0.3s ease; }
        .player-control-btn.active { color: theme('colors.accent'); }
    </style>
</head>
<body class="font-sans antialiased">

    <div id="app-container" class="h-full w-full max-w-lg mx-auto flex flex-col relative bg-transparent text-text-primary">
        
        <header id="header" class="fixed top-0 left-0 right-0 max-w-lg mx-auto bg-bg-secondary z-20 px-4 pt-12 pb-4">
            <div class="flex items-center justify-between">
                <button id="back-button" class="hidden p-2 -ml-2"><i data-lucide="chevron-left" class="w-7 h-7"></i></button>
                <h1 id="header-title" class="text-4xl font-black text-transparent bg-clip-text bg-gradient-to-r from-white to-neutral-400">Home</h1>
                <div class="w-7"></div>
            </div>
            <div id="search-container" class="relative mt-4 hidden opacity-0 -translate-y-2">
                <i data-lucide="search" class="absolute left-3 top-1/2 -translate-y-1/2 w-5 h-5 text-text-tertiary"></i>
                <input id="search-input" type="text" class="w-full py-2.5 pl-10 pr-10 text-text-primary bg-bg-tertiary rounded-lg focus:outline-none focus:ring-2 focus:ring-accent" placeholder="Songs, Artists, Playlists">
                <button id="search-clear-btn" class="absolute right-3 top-1/2 -translate-y-1/2 p-1 text-text-tertiary hover:text-text-primary hidden"><i data-lucide="x" class="w-5 h-5"></i></button>
            </div>
        </header>

        <main id="main-content" class="flex-grow overflow-y-auto pt-36 pb-40">
            <div id="content-area" class="px-4"></div>
            <div id="loader" class="hidden text-center py-10"><div class="animate-spin rounded-full h-8 w-8 border-b-2 border-text-tertiary mx-auto"></div></div>
        </main>

        <!-- REDESIGNED FLOATING MINI-PLAYER -->
        <div id="mini-player" class="fixed bottom-[6.5rem] left-1/2 -translate-x-1/2 w-full max-w-sm z-30 px-2 opacity-0 translate-y-full pointer-events-none" style="will-change: transform, opacity;">
            <div class="bg-bg-tertiary/80 backdrop-blur-xl p-2 rounded-full flex items-center gap-3 shadow-2xl relative overflow-hidden" style="box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3), 0 0 0 1px rgba(255, 255, 255, 0.1);">
                <div id="mini-player-progress" class="absolute bottom-0 left-0 h-0.5 bg-white transition-all duration-200 ease-linear" style="width: 0%;"></div>
                <img id="mini-player-thumbnail" src="" class="w-10 h-10 rounded-full flex-shrink-0">
                <div id="mini-player-click-area" class="flex-grow overflow-hidden cursor-pointer">
                    <p id="mini-player-title" class="font-semibold truncate"></p>
                </div>
                <button id="mini-play-pause-btn" class="p-2 text-text-primary active:scale-90 transition-transform flex-shrink-0 mr-1"></button>
            </div>
        </div>

        <!-- REDESIGNED ICON-ONLY FLOATING NAVIGATION -->
        <nav id="main-nav" class="fixed bg-bg-primary/80 backdrop-blur-xl z-20">
            <div class="flex justify-around items-center h-auto p-2 gap-6">
                <button id="home-tab" class="tab-item text-center active"><div class="icon-wrapper"><i data-lucide="home" class="w-6 h-6"></i></div></button>
                <button id="browse-tab" class="tab-item text-center text-text-secondary"><div class="icon-wrapper"><i data-lucide="search" class="w-6 h-6"></i></div></button>
                <button id="library-tab" class="tab-item text-center text-text-secondary"><div class="icon-wrapper"><i data-lucide="library" class="w-6 h-6"></i></div></button>
            </div>
        </nav>

        <!-- FULL PLAYER -->
        <div id="full-player" class="fixed inset-0 bg-bg-secondary z-40 flex flex-col opacity-0 translate-y-full scale-95 pointer-events-none">
            <div id="player-bg" class="absolute inset-0 transition-all duration-1000 ease-in-out"></div>
            <div id="dismiss-handle" class="absolute top-4 left-1/2 -translate-x-1/2 w-10 h-1.5 bg-white/30 rounded-full z-30 cursor-grab active:cursor-grabbing"></div>
            
            <div id="player-carousel" class="w-full h-full">
                <!-- Player pages container will be dynamically inserted here -->
            </div>

            <nav id="player-nav" class="fixed bg-black/30 backdrop-blur-xl z-30">
                <div class="flex justify-around items-center h-auto p-2 gap-6">
                    <button data-target-tab="home-tab" class="tab-item text-center text-text-secondary"><div class="icon-wrapper"><i data-lucide="home" class="w-6 h-6"></i></div></button>
                    <button data-target-tab="browse-tab" class="tab-item text-center text-text-secondary"><div class="icon-wrapper"><i data-lucide="search" class="w-6 h-6"></i></div></button>
                    <button data-target-tab="library-tab" class="tab-item text-center text-text-secondary"><div class="icon-wrapper"><i data-lucide="library" class="w-6 h-6"></i></div></button>
                </div>
            </nav>
        </div>

        <!-- QUEUE VIEW -->
        <div id="queue-view" class="fixed inset-0 bg-bg-secondary/80 backdrop-blur-xl z-50 flex flex-col p-4 pt-12 translate-y-full pointer-events-none opacity-0">
            <div class="flex items-center justify-between mb-4">
                <h2 class="text-2xl font-bold">Up Next</h2>
                <button id="close-queue-btn" class="p-2"><i data-lucide="x" class="w-6 h-6"></i></button>
            </div>
            <div id="queue-list" class="flex-grow overflow-y-auto"></div>
        </div>

        <!-- CONTEXT MENU FOR LONG PRESS -->
        <div id="context-menu-backdrop" class="fixed inset-0 bg-black/30 z-40 hidden"></div>
        <div id="context-menu" class="fixed bottom-0 left-0 right-0 max-w-lg mx-auto bg-bg-tertiary/80 backdrop-blur-xl p-4 rounded-t-2xl z-50 hidden translate-y-full transition-transform duration-300 ease-out" data-item-id="">
            <div id="context-menu-header" class="flex items-center gap-4 mb-4">
                <img id="context-menu-thumbnail" src="" class="w-12 h-12 rounded-md">
                <div>
                    <p id="context-menu-title" class="font-semibold text-text-primary"></p>
                    <p id="context-menu-channel" class="text-sm text-text-secondary"></p>
                </div>
            </div>
            <button id="context-menu-delete" class="w-full flex items-center gap-3 p-3 rounded-lg hover:bg-white/10 text-red-500">
                <i data-lucide="trash-2" class="w-5 h-5"></i>
                <span>Remove from History</span>
            </button>
        </div>

        <div id="youtube-player" class="fixed -bottom-[500px] -left-[500px]"></div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- CONFIGURATION ---
        const API_KEY = 'AIzaSyB76sWuDITCR3lApwpbrxBrUol9MXoN1rI'; // ⬇️ PASTE YOUR YOUTUBE API KEY HERE ⬇️
        const MAX_HISTORY_SIZE = 50;
        
        // --- STATE ---
        let ytPlayer, playerStateInterval, isSeeking = false, isExpandingQueue = false, isAnimatingScroll = false;
        let longPressTimer = null;
        const state = { 
            currentTrack: null, 
            queue: [], 
            originalQueue: [],
            queueIndex: -1, 
            isPlaying: false,
            isShuffling: false,
            repeatMode: 'none' // 'none', 'all', 'one'
        };

        // --- DOM ELEMENTS ---
        const dom = {
            header: document.getElementById('header'), headerTitle: document.getElementById('header-title'), backButton: document.getElementById('back-button'),
            searchContainer: document.getElementById('search-container'), searchInput: document.getElementById('search-input'), searchClearBtn: document.getElementById('search-clear-btn'),
            contentArea: document.getElementById('content-area'), loader: document.getElementById('loader'),
            mainContent: document.getElementById('main-content'), miniPlayer: document.getElementById('mini-player'),
            miniPlayerClickArea: document.getElementById('mini-player-click-area'), miniPlayerThumbnail: document.getElementById('mini-player-thumbnail'),
            miniPlayerTitle: document.getElementById('mini-player-title'), miniPlayPauseBtn: document.getElementById('mini-play-pause-btn'),
            fullPlayer: document.getElementById('full-player'), playerBg: document.getElementById('player-bg'),
            playerCarousel: document.getElementById('player-carousel'), playerPagesContainer: null,
            dismissHandle: document.getElementById('dismiss-handle'),
            playerNav: document.getElementById('player-nav'),
            tabs: { home: document.getElementById('home-tab'), browse: document.getElementById('browse-tab'), library: document.getElementById('library-tab') },
            queueView: document.getElementById('queue-view'), queueList: document.getElementById('queue-list'), closeQueueBtn: document.getElementById('close-queue-btn'),
            contextMenu: {
                backdrop: document.getElementById('context-menu-backdrop'),
                menu: document.getElementById('context-menu'),
                thumbnail: document.getElementById('context-menu-thumbnail'),
                title: document.getElementById('context-menu-title'),
                channel: document.getElementById('context-menu-channel'),
                deleteBtn: document.getElementById('context-menu-delete'),
            }
        };

        // --- DATABASE (IndexedDB) ---
        const DB = {
            db: null,
            init() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open('ICON_DB_V2', 2);
                    request.onerror = (e) => reject("IndexedDB error: " + e.target.errorCode);
                    request.onsuccess = (e) => { this.db = e.target.result; resolve(); };
                    request.onupgradeneeded = (e) => {
                        const db = e.target.result;
                        if (!db.objectStoreNames.contains('history')) {
                            const store = db.createObjectStore('history', { keyPath: 'videoId' });
                            store.createIndex('timestamp', 'timestamp', { unique: false });
                        }
                    };
                });
            },
            addHistory(track) {
                return new Promise((resolve, reject) => {
                    const tx = this.db.transaction('history', 'readwrite');
                    tx.onerror = (e) => reject(e.target.error);
                    tx.oncomplete = () => resolve();
                    const store = tx.objectStore('history');
                    store.put({ ...track, timestamp: Date.now() });
                    const index = store.index('timestamp');
                    index.count().onsuccess = (e) => {
                        if (e.target.result > MAX_HISTORY_SIZE) {
                            index.openCursor().onsuccess = (e) => {
                                const cursor = e.target.result;
                                if (cursor) store.delete(cursor.primaryKey);
                            };
                        }
                    };
                });
            },
            getHistory() {
                return new Promise((resolve, reject) => {
                    const tx = this.db.transaction('history', 'readonly');
                    const store = tx.objectStore('history');
                    const index = store.index('timestamp');
                    const request = index.getAll();
                    request.onerror = (e) => reject(e.target.error);
                    request.onsuccess = () => resolve(request.result.sort((a, b) => b.timestamp - a.timestamp));
                });
            },
            deleteHistory(videoId) {
                return new Promise((resolve, reject) => {
                    const tx = this.db.transaction('history', 'readwrite');
                    tx.onerror = (e) => reject(e.target.error);
                    tx.oncomplete = () => resolve();
                    const store = tx.objectStore('history');
                    store.delete(videoId);
                });
            }
        };

        // --- YOUTUBE API ---
        const API = {
            async fetch(endpoint, params) {
                if (API_KEY.includes('YOUR_YOUTUBE_API_KEY')) {
                    console.error("API Key is not set.");
                    throw new Error("API Key not configured.");
                }
                const url = new URL(`https://www.googleapis.com/youtube/v3/${endpoint}`);
                url.searchParams.append('key', API_KEY);
                for (const key in params) url.searchParams.append(key, params[key]);
                const response = await fetch(url);
                if (!response.ok) {
                    const errorData = await response.json();
                    const message = errorData.error?.message || `API Error (${response.status})`;
                    console.error(message);
                    throw new Error(message);
                }
                return await response.json();
            },
            search(query, type = 'video,playlist') {
                const params = { part: 'snippet', q: query, type: type, maxResults: 25 };
                if (type === 'video') params.videoCategoryId = '10';
                return this.fetch('search', params);
            },
            getTopHits() {
                return this.fetch('videos', { part: 'snippet', chart: 'mostPopular', regionCode: 'US', videoCategoryId: '10', maxResults: 20 });
            },
            getRelated(videoId) {
                return this.fetch('search', { part: 'snippet', relatedToVideoId: videoId, type: 'video', maxResults: 15, videoCategoryId: '10' });
            },
            getPlaylistItems(playlistId) {
                return this.fetch('playlistItems', { part: 'snippet', playlistId: playlistId, maxResults: 50 });
            }
        };

        // --- PLAYER LOGIC ---
        const Player = {
            init() {
                const tag = document.createElement('script');
                tag.src = "https://www.youtube.com/iframe_api";
                document.head.appendChild(tag);
                window.onYouTubeIframeAPIReady = () => {
                    ytPlayer = new YT.Player('youtube-player', {
                        height: '360', width: '640',
                        playerVars: { 'playsinline': 1, 'autoplay': 1, 'controls': 0, 'disablekb': 1, 'fs': 0, 'iv_load_policy': 3, 'modestbranding': 1, 'rel': 0 },
                        events: { 'onStateChange': this.onStateChange }
                    });
                };
            },
            onStateChange(event) {
                state.isPlaying = event.data === YT.PlayerState.PLAYING;
                UI.updateAllPlayPauseIcons(state.isPlaying);
                if (event.data === YT.PlayerState.PLAYING) {
                    Player.startProgressInterval();
                    const duration = ytPlayer.getDuration();
                    const totalDurationEl = document.querySelector(`#player-page-${state.queueIndex} #total-duration`);
                    if (totalDurationEl) totalDurationEl.textContent = UI.formatTime(duration);
                    const progressBar = document.querySelector(`#player-page-${state.queueIndex} #progress-bar`);
                    if (progressBar) progressBar.max = duration;
                } else {
                    clearInterval(playerStateInterval);
                }
                if (event.data === YT.PlayerState.ENDED) this.handleTrackEnd();
            },
            handleTrackEnd() {
                if (state.repeatMode === 'one') {
                    this.playCurrentIndex();
                } else {
                    this.changeTrack(1);
                }
            },
            async playTrack(track, contextQueue = null) {
                const validQueue = (contextQueue || [track]).filter(t => t && t.videoId);
                const newIndex = validQueue.findIndex(t => t.videoId === track.videoId);
                
                state.queue = [...validQueue];
                state.originalQueue = [...validQueue];
                state.queueIndex = newIndex > -1 ? newIndex : 0;
                
                UI.buildPlayerCarousel();
                this.playCurrentIndex();
                await this.populateQueueIfNeeded(track);
            },
            playCurrentIndex() {
                if (state.queueIndex < 0 || state.queueIndex >= state.queue.length) return;
                const track = state.queue[state.queueIndex];
                state.currentTrack = track;
                ytPlayer.loadVideoById(track.videoId);
                DB.addHistory(track).catch(console.error);
                UI.updatePlayerUI(track);
                UI.showMiniPlayer();
            },
            async populateQueueIfNeeded(track) {
                if (state.queue.length > 1) return;
                try {
                    const relatedData = await API.getRelated(track.videoId);
                    const relatedTracks = relatedData?.items?.map(UI.formatItem).filter(Boolean) || [];
                    state.queue = [track, ...relatedTracks];
                    state.originalQueue = [...state.queue];
                    UI.buildPlayerCarousel();
                } catch (error) { console.warn("Could not fetch related videos for initial queue."); }
            },
            async expandQueue() {
                if (isExpandingQueue || state.queue.length === 0) return;
                isExpandingQueue = true;
                const seedVideoId = state.queue[state.queue.length - 1].videoId;
                try {
                    const relatedData = await API.getRelated(seedVideoId);
                    const newTracks = relatedData?.items?.map(UI.formatItem).filter(Boolean);
                    if (newTracks && newTracks.length > 0) {
                        state.queue.push(...newTracks);
                        state.originalQueue.push(...newTracks);
                        UI.appendPlayerPages(newTracks);
                    }
                } catch (error) { console.error("Failed to expand queue:", error); }
                finally { isExpandingQueue = false; }
            },
            togglePlayPause() { if (!state.currentTrack) return; state.isPlaying ? ytPlayer.pauseVideo() : ytPlayer.playVideo(); },
            changeTrack(direction) { // direction is 1 for next, -1 for previous
                if (isAnimatingScroll) return;
                let newIndex = state.queueIndex + direction;

                if (newIndex >= state.queue.length) {
                    if (state.repeatMode === 'all') newIndex = 0;
                    else return; // End of queue
                }
                if (newIndex < 0) {
                    return; // Start of queue
                }
                this.jumpToQueueIndex(newIndex);
            },
            jumpToQueueIndex(index) {
                if (isAnimatingScroll || index < 0 || index >= state.queue.length) return;
                isAnimatingScroll = true;
                
                UI.transitionCarouselToIndex(index);
                state.queueIndex = index;
                this.playCurrentIndex();
                
                if (state.queueIndex >= state.queue.length - 3) this.expandQueue();
                setTimeout(() => { isAnimatingScroll = false; }, 500);
            },
            toggleShuffle() {
                state.isShuffling = !state.isShuffling;
                const currentTrack = state.queue[state.queueIndex];
                if (state.isShuffling) {
                    const upcoming = state.queue.slice(state.queueIndex + 1);
                    for (let i = upcoming.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [upcoming[i], upcoming[j]] = [upcoming[j], upcoming[i]];
                    }
                    state.queue = state.queue.slice(0, state.queueIndex + 1).concat(upcoming);
                } else {
                    const originalIndex = state.originalQueue.findIndex(t => t.videoId === currentTrack.videoId);
                    state.queue = [...state.originalQueue];
                    state.queueIndex = originalIndex;
                }
                UI.updatePlayerControls();
                UI.buildPlayerCarousel();
            },
            toggleRepeat() {
                const modes = ['none', 'all', 'one'];
                const currentIndex = modes.indexOf(state.repeatMode);
                state.repeatMode = modes[(currentIndex + 1) % modes.length];
                UI.updatePlayerControls();
            },
            startProgressInterval() {
                clearInterval(playerStateInterval);
                playerStateInterval = setInterval(() => {
                    if (!isSeeking && ytPlayer.getDuration) {
                        const currentTime = ytPlayer.getCurrentTime();
                        const duration = ytPlayer.getDuration();
                        const progressPercent = duration > 0 ? (currentTime / duration) * 100 : 0;

                        const miniProgress = document.getElementById('mini-player-progress');
                        if (miniProgress) miniProgress.style.width = `${progressPercent}%`;

                        const currentPage = document.querySelector(`#player-page-${state.queueIndex}`);
                        if (currentPage) {
                            const progressBar = currentPage.querySelector('#progress-bar');
                            const currentTimeEl = currentPage.querySelector('#current-time');
                            progressBar.value = currentTime;
                            currentTimeEl.textContent = UI.formatTime(currentTime);
                            progressBar.style.setProperty('--progress', `${progressPercent}%`);
                        }
                    }
                }, 250);
            }
        };

        // --- UI & RENDERING ---
        const UI = {
            showLoader() { dom.loader.classList.remove('hidden'); dom.contentArea.innerHTML = ''; },
            hideLoader() { dom.loader.classList.add('hidden'); },
            formatTime(seconds) { const min = Math.floor(seconds / 60); const sec = Math.floor(seconds % 60).toString().padStart(2, '0'); return `${min}:${sec}`; },
            formatItem(item) {
                if (!item || !item.snippet) return null;
                const isPlaylist = item.id?.kind === 'youtube#playlist';
                const id = isPlaylist ? item.id.playlistId : (item.id?.videoId || item.id);
                if (!id) return null;
                return {
                    id, videoId: isPlaylist ? null : id, playlistId: isPlaylist ? id : null,
                    title: item.snippet.title, channel: item.snippet.channelTitle,
                    thumbnail: item.snippet.thumbnails?.high?.url || item.snippet.thumbnails?.medium?.url, isPlaylist
                };
            },
            createItemCard(itemData) {
                if (!itemData || !itemData.thumbnail) return '';
                return `<div class="item-card flex items-center gap-4 p-2 rounded-lg hover:bg-bg-tertiary cursor-pointer transition-all duration-200 hover:scale-[1.02]" data-item='${JSON.stringify(itemData)}'><img src="${itemData.thumbnail}" class="w-20 h-20 rounded-md object-cover flex-shrink-0" loading="lazy"><div class="flex-1 overflow-hidden"><p class="font-semibold truncate text-text-primary">${itemData.title}</p><p class="text-text-secondary text-sm truncate">${itemData.channel}</p></div>${itemData.isPlaylist ? `<i data-lucide="list-music" class="w-5 h-5 text-accent flex-shrink-0"></i>` : ''}</div>`;
            },
            renderSection(title, items, cardRenderer) {
                if (!items || items.length === 0) return '';
                const validItems = items.filter(Boolean);
                const itemsHtml = validItems.map(cardRenderer).join('');
                return `<div class="mb-8" data-context-queue='${JSON.stringify(validItems)}'><h2 class="text-3xl font-extrabold text-transparent bg-clip-text bg-gradient-to-r from-neutral-200 to-neutral-500 mb-4">${title}</h2><div class="space-y-2">${itemsHtml}</div></div>`;
            },
            buildPlayerCarousel() {
                const pagesHtml = state.queue.map(this.createPlayerPage).join('');
                dom.playerCarousel.innerHTML = `<div id="player-pages-container" class="h-full w-full" style="transition: transform 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);">${pagesHtml}</div>`;
                dom.playerPagesContainer = document.getElementById('player-pages-container');
                this.transitionCarouselToIndex(state.queueIndex, true);
                lucide.createIcons();
                this.updatePlayerControls();
            },
            appendPlayerPages(tracks) {
                if (!dom.playerPagesContainer) return;
                const startingIndex = state.queue.length - tracks.length;
                const newPagesHtml = tracks.map((track, i) => this.createPlayerPage(track, startingIndex + i)).join('');
                dom.playerPagesContainer.insertAdjacentHTML('beforeend', newPagesHtml);
                lucide.createIcons();
            },
            transitionCarouselToIndex(index, instant = false) {
                if (!dom.playerPagesContainer) return;
                if (instant) dom.playerPagesContainer.style.transition = 'none';
                dom.playerPagesContainer.style.transform = `translateY(-${index * 100}vh)`;
                if (instant) requestAnimationFrame(() => dom.playerPagesContainer.style.transition = '');
            },
            createPlayerPage(track, index) {
                return `
                    <div id="player-page-${index}" class="w-full h-full flex-shrink-0 relative flex flex-col justify-between p-6 pt-20 pb-28">
                        <div class="flex-shrink-0"></div>
                        <div class="flex flex-col items-center">
                            <img src="${track.thumbnail}" class="w-full max-w-xs aspect-square rounded-xl shadow-2xl mb-8" style="transform: perspective(1000px) rotateY(5deg); box-shadow: -10px 10px 30px rgba(0,0,0,0.4);">
                            <div class="text-center w-full px-4">
                                <h2 class="text-2xl font-bold">${track.title}</h2>
                                <p class="text-lg text-text-secondary mt-1">${track.channel}</p>
                            </div>
                        </div>
                        <div class="w-full">
                            <div class="w-full mt-8">
                                <input id="progress-bar" type="range" min="0" max="100" value="0" style="--progress: 0%;">
                                <div class="flex justify-between text-xs text-text-secondary mt-1">
                                    <span id="current-time">0:00</span>
                                    <span id="total-duration">0:00</span>
                                </div>
                            </div>
                            <div class="flex justify-around items-center mt-6">
                                <button class="shuffle-btn player-control-btn text-text-secondary active:scale-90 transition-transform"><i data-lucide="shuffle" class="w-6 h-6"></i></button>
                                <button class="prev-btn text-text-secondary active:scale-90 transition-transform"><i data-lucide="skip-back" class="w-8 h-8"></i></button>
                                <button class="play-pause-btn p-5 bg-white rounded-full text-black active:scale-90 transition-transform shadow-lg"></button>
                                <button class="next-btn text-text-secondary active:scale-90 transition-transform"><i data-lucide="skip-forward" class="w-8 h-8"></i></button>
                                <button class="repeat-btn player-control-btn text-text-secondary active:scale-90 transition-transform"><i data-lucide="repeat" class="w-6 h-6"></i></button>
                            </div>
                            <div class="flex justify-end mt-4 px-4">
                                <button class="queue-btn text-text-secondary"><i data-lucide="list-music" class="w-6 h-6"></i></button>
                            </div>
                        </div>
                    </div>
                `;
            },
            updatePlayerUI(track) {
                dom.miniPlayerThumbnail.src = track.thumbnail;
                dom.miniPlayerTitle.textContent = track.title;
                dom.playerBg.style.background = `linear-gradient(to bottom, rgba(30,30,30,0.8), #121212 50%), url(${track.thumbnail})`;
                dom.playerBg.style.backgroundSize = 'cover'; dom.playerBg.style.backgroundPosition = 'center';
                dom.playerBg.style.filter = 'blur(80px) brightness(0.8)';
            },
            updateAllPlayPauseIcons(isPlaying) {
                const playIcon = `<i data-lucide="play" class="w-6 h-6"></i>`; const pauseIcon = `<i data-lucide="pause" class="w-6 h-6"></i>`;
                const largePlayIcon = `<i data-lucide="play" class="w-10 h-10 fill-black ml-1"></i>`; const largePauseIcon = `<i data-lucide="pause" class="w-10 h-10 fill-black"></i>`;
                dom.miniPlayPauseBtn.innerHTML = isPlaying ? pauseIcon : playIcon;
                document.querySelectorAll('.play-pause-btn').forEach(btn => {
                    btn.innerHTML = isPlaying ? largePauseIcon : largePlayIcon;
                });
                lucide.createIcons();
            },
            updatePlayerControls() {
                const shuffleBtn = document.querySelector('.shuffle-btn');
                const repeatBtn = document.querySelector('.repeat-btn');
                if (shuffleBtn) shuffleBtn.classList.toggle('active', state.isShuffling);
                if (repeatBtn) {
                    repeatBtn.classList.toggle('active', state.repeatMode !== 'none');
                    if (state.repeatMode === 'one') repeatBtn.innerHTML = `<i data-lucide="repeat-1" class="w-6 h-6"></i>`;
                    else repeatBtn.innerHTML = `<i data-lucide="repeat" class="w-6 h-6"></i>`;
                    lucide.createIcons();
                }
            },
            showMiniPlayer() { dom.miniPlayer.classList.remove('opacity-0', 'translate-y-full', 'pointer-events-none'); dom.mainContent.style.paddingBottom = '160px'; },
            showFullPlayer() { dom.fullPlayer.classList.remove('opacity-0', 'translate-y-full', 'scale-95', 'pointer-events-none'); },
            hideFullPlayer() { dom.fullPlayer.classList.add('opacity-0', 'translate-y-full', 'scale-95', 'pointer-events-none'); },
            setActiveTab(activeTab) {
                document.querySelectorAll('#main-nav .tab-item, #player-nav .tab-item').forEach(tab => {
                    tab.classList.remove('active');
                    tab.classList.add('text-text-secondary');
                });
                const mainTab = document.getElementById(activeTab.id);
                const playerTab = document.querySelector(`#player-nav [data-target-tab="${activeTab.id}"]`);
                if(mainTab) { mainTab.classList.add('active'); mainTab.classList.remove('text-text-secondary'); }
                if(playerTab) { playerTab.classList.add('active'); playerTab.classList.remove('text-text-secondary'); }
            },
            updateHeader(title, showSearch = false, showBack = false) {
                dom.headerTitle.textContent = title;
                if (showSearch) {
                    dom.searchContainer.classList.remove('hidden', 'opacity-0', '-translate-y-2');
                } else {
                    dom.searchContainer.classList.add('opacity-0', '-translate-y-2');
                    setTimeout(() => dom.searchContainer.classList.add('hidden'), 300);
                }
                dom.backButton.style.display = showBack ? 'block' : 'none';
                dom.headerTitle.style.textAlign = showBack ? 'center' : 'left';
                dom.headerTitle.style.flexGrow = showBack ? '1' : '0';
            },
            showContextMenu(itemData) {
                dom.contextMenu.thumbnail.src = itemData.thumbnail;
                dom.contextMenu.title.textContent = itemData.title;
                dom.contextMenu.channel.textContent = itemData.channel;
                dom.contextMenu.menu.dataset.itemId = itemData.videoId;
                dom.contextMenu.backdrop.classList.remove('hidden');
                dom.contextMenu.menu.classList.remove('hidden');
                requestAnimationFrame(() => {
                    dom.contextMenu.menu.classList.remove('translate-y-full');
                });
            },
            hideContextMenu() {
                dom.contextMenu.menu.classList.add('translate-y-full');
                dom.contextMenu.backdrop.classList.add('hidden');
                setTimeout(() => {
                    dom.contextMenu.menu.classList.add('hidden');
                }, 300);
            },
            renderQueueView() {
                const queueHtml = state.queue.map((track, index) => `
                    <div class="queue-item flex items-center gap-4 p-2 rounded-lg cursor-pointer ${index === state.queueIndex ? 'bg-white/10' : 'hover:bg-white/5'}" data-index="${index}">
                        <img src="${track.thumbnail}" class="w-12 h-12 rounded-md object-cover flex-shrink-0">
                        <div class="flex-1 overflow-hidden">
                            <p class="font-semibold truncate ${index === state.queueIndex ? 'text-accent' : 'text-text-primary'}">${track.title}</p>
                            <p class="text-text-secondary text-sm truncate">${track.channel}</p>
                        </div>
                    </div>
                `).join('');
                dom.queueList.innerHTML = queueHtml;
            },
            showQueueView() {
                this.renderQueueView();
                dom.queueView.classList.remove('translate-y-full', 'opacity-0');
                dom.queueView.classList.add('pointer-events-auto');
            },
            hideQueueView() {
                dom.queueView.classList.add('translate-y-full', 'opacity-0');
                dom.queueView.classList.remove('pointer-events-auto');
            },
            async renderHomeView() { /* ... defined below ... */ },
            async renderBrowseView(query) { /* ... defined below ... */ },
            async renderLibraryView() { /* ... defined below ... */ },
            async renderPlaylistView(playlistData) { /* ... defined below ... */ },
        };
        
        // --- EVENT LISTENERS ---
        function setupEventListeners() {
            const debounce = (func, delay) => { let timeout; return (...args) => { clearTimeout(timeout); timeout = setTimeout(() => func.apply(this, args), delay); }; };
            
            dom.searchInput.addEventListener('input', debounce(e => {
                const query = e.target.value.trim();
                dom.searchClearBtn.classList.toggle('hidden', query.length === 0);
                if (query.length > 2) UI.renderBrowseView(query);
            }, 500));

            dom.searchClearBtn.addEventListener('click', () => {
                dom.searchInput.value = '';
                dom.searchClearBtn.classList.add('hidden');
                dom.contentArea.innerHTML = `<p class="text-text-secondary text-center py-10">Search for your favorite music.</p>`;
                dom.searchInput.focus();
            });

            // --- LONG PRESS LOGIC ---
            const handleLongPress = (e) => {
                if (!dom.tabs.library.classList.contains('active')) return;
                const card = e.target.closest('.item-card');
                if (!card || !card.dataset.item) return;
                try {
                    const itemData = JSON.parse(card.dataset.item);
                    if (itemData.isPlaylist) return;
                    UI.showContextMenu(itemData);
                } catch (err) { console.error("Error parsing item data for context menu:", err); }
            };
            const cancelLongPress = () => clearTimeout(longPressTimer);
            dom.contentArea.addEventListener('mousedown', e => { if (e.target.closest('.item-card')) longPressTimer = setTimeout(() => handleLongPress(e), 500); });
            dom.contentArea.addEventListener('mouseup', cancelLongPress);
            dom.contentArea.addEventListener('mouseleave', cancelLongPress);
            dom.contentArea.addEventListener('touchstart', e => { if (e.target.closest('.item-card')) longPressTimer = setTimeout(() => handleLongPress(e), 500); }, { passive: true });
            dom.contentArea.addEventListener('touchend', cancelLongPress);
            dom.contentArea.addEventListener('touchmove', cancelLongPress, { passive: true });

            dom.contentArea.addEventListener('click', e => {
                const card = e.target.closest('[data-item]');
                if (!card) return;
                try {
                    const itemData = JSON.parse(card.dataset.item);
                    if (itemData.isPlaylist) {
                        UI.updateHeader(itemData.title, false, true);
                        UI.renderPlaylistView(itemData);
                        return;
                    }
                    if (itemData.videoId) {
                        let contextQueue = null;
                        const contextContainer = card.closest('[data-context-queue]');
                        if (contextContainer) {
                            try { contextQueue = JSON.parse(contextContainer.dataset.contextQueue); } catch (queueError) { console.warn("Could not parse context queue."); }
                        }
                        Player.playTrack(itemData, contextQueue);
                    }
                } catch (err) { console.error("Failed to process click event:", err); }
            });

            dom.contextMenu.backdrop.addEventListener('click', UI.hideContextMenu);
            dom.contextMenu.deleteBtn.addEventListener('click', async () => {
                const videoId = dom.contextMenu.menu.dataset.itemId;
                if (!videoId) return;
                await DB.deleteHistory(videoId);
                UI.hideContextMenu();
                UI.renderLibraryView();
            });

            dom.backButton.addEventListener('click', () => { dom.tabs.browse.click(); });
            dom.miniPlayPauseBtn.addEventListener('click', e => { e.stopPropagation(); Player.togglePlayPause(); });
            dom.miniPlayerClickArea.addEventListener('click', UI.showFullPlayer);
            
            dom.playerCarousel.addEventListener('click', e => {
                if (e.target.closest('.play-pause-btn')) Player.togglePlayPause();
                if (e.target.closest('.next-btn')) Player.changeTrack(1);
                if (e.target.closest('.prev-btn')) Player.changeTrack(-1);
                if (e.target.closest('.shuffle-btn')) Player.toggleShuffle();
                if (e.target.closest('.repeat-btn')) Player.toggleRepeat();
                if (e.target.closest('.queue-btn')) UI.showQueueView();
            });
            dom.playerCarousel.addEventListener('input', e => { if (e.target.matches('#progress-bar')) { isSeeking = true; ytPlayer.seekTo(e.target.value, true); } });
            dom.playerCarousel.addEventListener('change', e => { if (e.target.matches('#progress-bar')) isSeeking = false; });

            let touchStartY = 0;
            dom.playerCarousel.addEventListener('touchstart', e => { touchStartY = e.touches[0].clientY; }, { passive: true });
            dom.playerCarousel.addEventListener('touchend', e => {
                const touchEndY = e.changedTouches[0].clientY;
                const deltaY = touchStartY - touchEndY;
                if (Math.abs(deltaY) > 50) { if (deltaY > 0) Player.changeTrack(1); else Player.changeTrack(-1); }
            }, { passive: true });
            dom.playerCarousel.addEventListener('wheel', e => { e.preventDefault(); if (e.deltaY > 0) Player.changeTrack(1); else Player.changeTrack(-1); }, { passive: false });

            let handleTouchStartY = 0;
            dom.dismissHandle.addEventListener('touchstart', e => { handleTouchStartY = e.touches[0].clientY; }, { passive: true });
            dom.dismissHandle.addEventListener('touchmove', e => {
                const deltaY = e.touches[0].clientY - handleTouchStartY;
                if (deltaY > 0) {
                    dom.fullPlayer.style.transition = 'none';
                    dom.fullPlayer.style.transform = `translateY(${deltaY}px) scale(${1 - deltaY / 5000})`;
                }
            }, { passive: true });
            dom.dismissHandle.addEventListener('touchend', () => {
                const transformY = new DOMMatrix(getComputedStyle(dom.fullPlayer).transform).m42;
                dom.fullPlayer.style.transition = '';
                if (transformY > 100) UI.hideFullPlayer();
                dom.fullPlayer.style.transform = '';
            });

            Object.values(dom.tabs).forEach(tab => tab.addEventListener('click', () => {
                UI.setActiveTab(tab);
                const tabId = tab.id;
                if (tabId === 'home-tab') { UI.updateHeader('Home'); UI.renderHomeView(); }
                else if (tabId === 'browse-tab') {
                    UI.updateHeader('Browse', true);
                    if (!dom.searchInput.value) { dom.contentArea.innerHTML = `<p class="text-text-secondary text-center py-10">Search for your favorite music.</p>`; } 
                    else { UI.renderBrowseView(dom.searchInput.value); }
                }
                else if (tabId === 'library-tab') { UI.updateHeader('Library'); UI.renderLibraryView(); }
            }));
            
            dom.playerNav.addEventListener('click', e => {
                const targetTabBtn = e.target.closest('.tab-item');
                if (!targetTabBtn) return;
                const targetTabId = targetTabBtn.dataset.targetTab;
                UI.hideFullPlayer();
                dom.fullPlayer.addEventListener('transitionend', () => {
                    document.getElementById(targetTabId).click();
                }, { once: true });
            });

            dom.closeQueueBtn.addEventListener('click', UI.hideQueueView);
            dom.queueList.addEventListener('click', e => {
                const item = e.target.closest('.queue-item');
                if (item && item.dataset.index) {
                    const index = parseInt(item.dataset.index, 10);
                    Player.jumpToQueueIndex(index);
                    UI.hideQueueView();
                }
            });
        };

        // --- INITIALIZATION ---
        async function main() {
            lucide.createIcons();
            UI.updateAllPlayPauseIcons(false);
            try {
                await DB.init();
                Player.init();
                setupEventListeners();
                UI.renderHomeView();
            } catch (error) {
                console.error("Initialization failed:", error);
                dom.contentArea.innerHTML = `<p class="text-red-500 text-center py-10">A critical error occurred. Please refresh the page.</p>`;
            }
        }
        
        UI.renderHomeView = async function() {
            this.showLoader();
            let topHitsData;
            try { topHitsData = await API.getTopHits(); } catch (error) {
                console.warn("Primary API (chart) failed, trying fallback search...");
                try { topHitsData = await API.search("Top Music Hits", "video"); } catch (fallbackError) { console.error("Fallback API search also failed:", fallbackError); }
            }
            const results = await Promise.allSettled([Promise.resolve(topHitsData), DB.getHistory()]);
            const [topHitsResult, historyResult] = results;
            let content = ``;
            if (topHitsResult.status === 'fulfilled' && topHitsResult.value?.items) { content += this.renderSection("Top Hits", topHitsResult.value.items.map(this.formatItem), this.createItemCard); }
            else { content += `<p class="text-text-secondary mb-8">Could not load Top Hits.</p>`; }
            if (historyResult.status === 'fulfilled' && historyResult.value.length > 0) { content += this.renderSection("Recently Played", historyResult.value.slice(0, 5), this.createItemCard); }
            dom.contentArea.innerHTML = content; this.hideLoader(); lucide.createIcons();
        };
        UI.renderBrowseView = async function(query) {
            this.showLoader();
            try {
                const data = await API.search(query);
                const results = data?.items?.map(this.formatItem).filter(Boolean) || [];
                dom.contentArea.innerHTML = this.renderSection(`Results for "${query}"`, results, this.createItemCard);
            } catch (error) { dom.contentArea.innerHTML = `<p class="text-text-secondary text-center py-10">Search failed. Please try again later.</p>`; }
            finally { this.hideLoader(); lucide.createIcons(); }
        };
        UI.renderLibraryView = async function() {
            this.showLoader();
            try {
                const history = await DB.getHistory();
                if (history.length === 0) { dom.contentArea.innerHTML = `<div class="text-center py-20"><i data-lucide="history" class="w-16 h-16 mx-auto text-text-tertiary"></i><h3 class="mt-4 text-xl font-semibold">No History</h3><p class="text-text-secondary mt-2">Songs you play will appear here.</p></div>`; }
                else { dom.contentArea.innerHTML = this.renderSection("Listening History", history, this.createItemCard); }
            } catch (error) { console.error("Failed to render library:", error); dom.contentArea.innerHTML = `<p class="text-text-secondary text-center py-10">Could not load your library.</p>`; }
            finally { this.hideLoader(); lucide.createIcons(); }
        };
        UI.renderPlaylistView = async function(playlistData) {
            this.showLoader();
            try {
                const data = await API.getPlaylistItems(playlistData.playlistId);
                const items = data?.items?.map(item => this.formatItem({ ...item, id: { videoId: item.snippet.resourceId.videoId } })).filter(item => item && item.thumbnail);
                let content = `<div class="flex flex-col items-center text-center mb-6"><img src="${playlistData.thumbnail}" class="w-40 h-40 rounded-lg shadow-lg mb-4"><h2 class="text-2xl font-bold">${playlistData.title}</h2><p class="text-text-secondary">${playlistData.channel}</p></div>`;
                content += this.renderSection("Tracks", items, this.createItemCard);
                dom.contentArea.innerHTML = content;
            } catch (error) { dom.contentArea.innerHTML = `<p class="text-text-secondary text-center py-10">Could not load playlist tracks.</p>`; }
            finally { this.hideLoader(); lucide.createIcons(); }
        };

        main();
    });
    </script>
</body>
</html>